---
layout: post
title: ! '>[转]一种Linux下隐藏文件的新方法'
categories: []
tags:
- Uncategorized
status: publish
type: post
published: true
meta:
  blogger_blog: jmp-eax.blogspot.com
  blogger_author: JMP
  blogger_250ca80ed681db3745a15b2b9f221f45_permalink: '2994325743374461791'
---
&gt;<p>一种Linux下隐藏文件的新方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>Author: wzt<br>EMail: <a href="mailto:wzt@xsec.org">wzt@xsec.org</a><br>Site: <a href="http://www.xsec.org/">http://www.xsec.org</a> &amp; <a href="http://hi.baidu.com/wzt85">http://hi.baidu.com/wzt85</a><br> Date: 2008-9-23</p> <p>一. 概述</p> <p>目前通用的隐藏文件方法还是hooksys_getdents64系统调用， 大致流程就是先调用原始的<br>sys_getdents64系统调用，然后在在buf中做过滤。修改sys_call_table是比较原始的rk技术了，<br>碰到好点的管理员， 基本上gdb一下vmlinux就能检测出来。 如何想做到更加隐蔽的话，就要<br>寻找新的技术。 inline hook也是目前比较流行的做法，不容易检测。本文通过讲解一种利用<br> inline hook内核中某函数， 来达到隐藏文件的方法。</p> <p>二. 剖析sys_getdnts64系统调用<br>想隐藏文件， 还是要从sys_dents64系统调用下手。 去看下它在内核中是如何实现的。<br>代码在linux-2.6.26/fs/readdir.c中：</p> <p>asmlinkage long sys_getdents64(unsigned int fd, struct linux_dirent64 __user * dirent, unsigned int count)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct file * file;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct linux_dirent64 __user * lastdirent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct getdents_callback64 buf;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int error;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = -EFAULT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!access_ok(VERIFY_WRITE, dirent, count))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = -EBADF;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file = fget(fd);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!file)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.current_dir = dirent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.previous = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.count = count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.error = 0;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = vfs_readdir(file, filldir64, &amp;buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (error &lt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out_putf;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = buf.error;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastdirent = buf.previous;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lastdirent) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(lastdirent-&gt;d_off) d_off = file-&gt;f_pos;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = -EFAULT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(d_off, &amp;lastdirent-&gt;d_off))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out_putf;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = count - buf.count;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p>out_putf:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fput(file);<br>out:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return error;<br>}</p> <p>首先调用access_ok来验证是下用户空间的dirent地址是否越界，是否可写。 接着根据fd，<br>利用fget找到对应的file结构。 接着出现了一个填充buf数据结构的操作，先不管它是干什么的，<br>接着往下看。<br>vfs_readdir(file, filldir64, &amp;buf);<br>函数最终还是调用vfs层的vfs_readdir来获取文件列表的。 到这，我们可以是否通过hook<br>vfs_readdir来达到隐藏文件的效果呢。 继续跟踪vfs_readdir看看这个想法是否可行。</p>  <p>源代码在同一文件中：</p> <p>int vfs_readdir(struct file *file, filldir_t filler, void *buf)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int res = -ENOTDIR;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!file-&gt;f_op || !file-&gt;f_op-&gt;readdir)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = security_file_permission(file, MAY_READ);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (res)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = mutex_lock_killable(&amp;inode-&gt;i_mutex);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (res)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = -ENOENT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!IS_DEADDIR(inode)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = file-&gt;f_op-&gt;readdir(file, buf, filler);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_accessed(file);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;inode-&gt;i_mutex);<br> out:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res;<br>}</p> <p>EXPORT_SYMBOL(vfs_readdir);</p> <p>它有3个参数，第一个是通过fget得到的file结构指针， 第2个通过结合上下文可得知，这是一个<br>回调函数用来填充第3个参数开始的用户空间的指针。 接着看看它具体是怎么实现的。<br>通过security_file_permission()验证后， 在用mutex_lock_killable()对inode结构加了锁。<br>然后调用ile-&gt;f_op-&gt;readdir(file, buf, filler);通过进一步的底层函数来对buf进行填充。<br> 这个buf就是用户空间strcut dirent64结构的开始地址。</p> <p>所以到这里我们可以断定通过hook vfs_readdir函数对buf做过滤还是可以完成隐藏文件的功能。<br>而且vfs_readdir的地址是导出的， 这样就不用复杂的方法找它的地址了。</p> <p>但是还有没有更进一步的方法呢？ 前面不是提到过有个filldir64函数吗， 它用来填充buf结构的。<br>也许通过hook它来做更隐蔽的隐藏文件方法。 继续跟踪filldir64，看看它是怎么实现的。</p> <p>static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u64 ino, unsigned int d_type)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct linux_dirent64 __user *dirent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct getdents_callback64 * buf = (struct getdents_callback64 *) __buf;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int reclen = ALIGN(NAME_OFFSET(dirent) + namlen + 1, sizeof(u64));</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf-&gt;error = -EINVAL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (reclen &gt; buf-&gt;count)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirent = buf-&gt;previous;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dirent) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(offset, &amp;dirent-&gt;d_off))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirent = buf-&gt;current_dir;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(ino, &amp;dirent-&gt;d_ino))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(0, &amp;dirent-&gt;d_off))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(reclen, &amp;dirent-&gt;d_reclen))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(d_type, &amp;dirent-&gt;d_type))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (copy_to_user(dirent-&gt;d_name, name, namlen))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__put_user(0, dirent-&gt;d_name + namlen))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto efault;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf-&gt;previous = dirent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirent = (void __user *)dirent + reclen;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf-&gt;current_dir = dirent;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf-&gt;count -= reclen;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>efault:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf-&gt;error = -EFAULT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EFAULT;<br>}</p> <p>先把参数buf转换成struct getdents_callback64的结构指针。<br>struct getdents_callback64 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct linux_dirent64 __user * current_dir;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct linux_dirent64 __user * previous;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int error;<br> };<br>current_dir始终指向当前的struct dirent64结构，filldir64每次只填充一个dirent64结构。<br>它是被file-&gt;f_op-&gt;readdir循环调用的。 通过代码可以看出是把dirent64结构的相关项拷贝到<br>用户空间的dirent64结构中， 然后更新相应的指针。</p> <p>所以通过分析filldir64代码， 可以判定通过判断参数name，看它是否是我们想隐藏的文件，<br>是的话，return 0就好了。</p> <p>三. 扩展</p> <p>通过分析sys_getdents64代码的实现，我们可以了解到通过hook内核函数的方法，来完成<br>rootkit的功能是很简单和方便的。 关键你能了解它的实现逻辑。 对linux平台来说，阅读内核<br>源代码是开发rootkit的根本。 如何hook？ 最简单的就是修改函数的前几个字节，jmp到我们的<br>新函数中去， 在新函数完成类似函数的功能。 根本不必在跳回原函数了， 有了内核源代码在手，<br>原函数怎么实现，我们就怎么copy过去给它在实现一次。 所在linux实现rk也有很方便的一点，<br> 就是它的内核源代码是公开的， 好好阅读源代码吧， 你会有更多的收获</p> <p>本篇文章来源于 黑客啦 原文链接：<a href="http://www.hack4.com/article/sort011/info-270.html?njenaed=26796">http://www.hack4.com/article/sort011/info-270.html?njenaed=26796</a></p>
