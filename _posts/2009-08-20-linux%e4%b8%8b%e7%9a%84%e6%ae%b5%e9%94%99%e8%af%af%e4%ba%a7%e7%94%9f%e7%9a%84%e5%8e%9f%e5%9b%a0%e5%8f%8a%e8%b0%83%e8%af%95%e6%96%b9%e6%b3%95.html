---
layout: post
title: ! '>Linux下的段错误产生的原因及调试方法'
categories: []
tags:
- Uncategorized
status: publish
type: post
published: true
meta:
  blogger_blog: jmp-eax.blogspot.com
  blogger_author: JMP
  blogger_250ca80ed681db3745a15b2b9f221f45_permalink: '4762461530729042300'
---
&gt;本文内容摘录自过个网站。在Linux下C/C++应用程序段错误经常发生，如何快速准确定位到出错地方，是本文讨论的主要内容。这里介绍两种不同环境下 的解决方法，带gdb调试环境的开发环境和不带gdb的嵌入式或发布环境。这些方法的关键都是利用程序运行调用堆栈来定位出错地点。<br> 关键词：段错误(Segmentation fault)，SIGSEGV，gdb，backtrace，objdump<br> <br> 一、段错误简要介绍和分析<br> [参见<a class="moz-txt-link-freetext" href="http://www.upsdn.net/html/2006-11/775.html">http://www.upsdn.net/html/2006-11/775.html</a>]<br> 简而言之,产生段错误就是访问了错误的内存段，一般是你没有权限，或者根本就不存在对应的物理内存,尤其常见的是访问0地址.<br> <br> 一般来说, 段错误就是指访问的内存超出了系统所给这个程序的内存空间，通常这个值是由gdtr来保存的，他是一个48位的寄存器，其中的32位是保存由它指向的 gdt表，后13位保存相应于gdt的下标，最后3位包括了程序是否在内存中以及程序的在cpu中的运行级别,指向的gdt是由以64位为一个单位的表， 在这张表中就保存着程序运行的代码段以及数据段的起始地址以及与此相应的段限和页面交换还有程序运行级别还有内存粒度等等的信息。一旦一个程序发生了越界 访问，cpu就会产生相应的异常保护，于是segmentation fault就出现了.<br> <br> 在编程中以下几类做法容易导致段错误,基本是是错误地使用指针引起的<br> <br> 1)访问系统数据区，尤其是往  系统保护的内存地址写数据<br>    最常见就是给一个指针以0地址<br> 2)内存越界(数组越界，变量类型不一致等) 访问到不属于你的内存区域<br> <br> 二、解决方案<br> <ol>   <li>带GDB调试环境</li> </ol> 先上例子再说。文件d.c内容如下<br>      1  dummy_function (void)<br>      2  {<br>      3          unsigned char *ptr = 0x00;<br>      4          *ptr = 0x00;<br>      5  }<br>      6<br>      7  int main (void)<br>      8  {<br>      9          dummy_function ();<br>     10<br>     11          return 0;<br>     12  }<br> 第四行会造成段错误。<br> gcc -g d.c -o d 编译生成可执行程序d<br> 运行结果如下<br> [chen@localhost seg]$ ./d<br> Segmentation fault<br> <br> 用gdb调试<br> [chen@localhost seg]$ gdb ./d<br> GNU gdb Red Hat Linux (6.5-25.el5rh)<br> Copyright (C) 2006 Free Software Foundation, Inc.<br> GDB is free software, covered by the GNU General Public License, and you are<br> welcome to change it and/or distribute copies of it under certain conditions.<br> Type "show copying" to see the conditions.<br> There is absolutely no warranty for GDB.  Type "show warranty" for details.<br> This GDB was configured as "i386-redhat-linux-gnu"...Using host libthread_db library "/lib/libthread_db.so.1".<br> <br> (gdb) r<br> Starting program: /home/chen/code/seg/d<br> <br> Program received signal SIGSEGV, Segmentation fault.<br> 0x08048364 in dummy_function () at d.c:28<br> 4              *ptr = 0x00;<br> <br> (gdb) backtrace<br> #0  0x08048364 in dummy_function () at d.c:4<br> #1  0x0804837c in main () at d.c:9<br> <br> 按上述步骤，能够清晰看到C文件产生段错误信号SIGSEGV在函数dummy_function()的第四行，和我们判断的一样，backtrace打 印堆栈调用<br> 也是如此。<br> <br> <br> 下面看一个C++例子，多调用一些模板库，会让调试麻烦些，但是这是比较接近实际应用情况。<br> 文件iterbug.cpp内容如下<br>      1  #include &lt;iostream&gt;<br>      2  #include &lt;vector&gt;<br>      3  #include &lt;iterator&gt;<br>      4  #include &lt;algorithm&gt;<br>      5  using namespace std;<br>      6<br>      7  void dummy_function(void)<br>      8  {<br>      9          vector&lt;int&gt; coll1;<br>     10          vector&lt;int&gt; coll2;<br>     11<br>     12          /*<br>     13           * RUNTIME ERROR:<br>     14           * - beginning is behind the end of the range<br>     15           */<br>     16          vector&lt;int&gt;::iterator pos = coll1.begin();<br>     17          reverse (++pos,coll1.end());<br>     18<br>     19<br>     20          for ( int i=1; i&lt;=9 ;++i )<br>     21                  coll2.push_back(i);<br>     22<br>     23          /*<br>     24           * RUNTIME ERROR:<br>     25           * - overwriting nonexisting elements<br>     26           */<br>     27          copy(coll2.begin(), coll2.end(),<br>     28                          coll1.begin());<br>     29<br>     30          /*<br>     31           * RUNTTIME ERROR:<br>     32           * - collections mistaken<br>     33           *   begin() and end() mistaken<br>     34           */<br>     35          copy(coll1.begin(), coll2.end(),<br>     36                          coll1.end());<br>     37  }<br>     38  int main()<br>     39  {<br>     40          dummy_function();<br>     41          return 0;<br>     42  }<br> <br> 三个运行时错误都在代码中注释出来了，后面两个根本不会执行，因为第一个运行时错误会造成程序终止。<br>  g++ -g iterbug.cpp -o iterbug<br> 将程序编译<br> 运行<br> [chen@localhost seg]$ ./iterbug<br> Segmentation fault<br> [chen@localhost seg]$ gdb ./iterbug<br> GNU gdb Red Hat Linux (6.5-25.el5rh)<br> Copyright (C) 2006 Free Software Foundation, Inc.<br> GDB is free software, covered by the GNU General Public License, and you are<br> welcome to change it and/or distribute copies of it under certain conditions.<br> Type "show copying" to see the conditions.<br> There is absolutely no warranty for GDB.  Type "show warranty" for details.<br> This GDB was configured as "i386-redhat-linux-gnu"...Using host libthread_db library "/lib/libthread_db.so.1".<br> <br> (gdb) r<br> Starting program: /home/chen/code/seg/iterbug<br> <br> Program received signal SIGSEGV, Segmentation fault.<br> 0x08048bbf in std::swap&lt;int&gt; (__a=@0x4, __b=@0xfffffffc)<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algobase.h:97<br> 97            _Tp __tmp = __a;<br> 这时候进入了STL的代码里面，这里不太容易看出自身代码是哪里出错。就用backtrace查看堆栈情况<br> <font color="#ff6666"><b>(gdb) backtrace</b></font><br> #0  0x08048bbf in std::swap&lt;int&gt; (__a=@0x4, __b=@0xfffffffc)<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algobase.h:97<br> #1  0x08048c03 in std::__iter_swap&lt;true&gt;::iter_swap&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; (__a={_M_current = 0x4}, __b=<br>       {_M_current = 0xfffffffc})<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algobase.h:127<br> #2  0x08048c22 in std::iter_swap&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; (__a={_M_current = 0x4}, __b=<br>       {_M_current = 0xfffffffc})<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algobase.h:163<br> #3  0x08048c5f in std::__reverse&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; (__first={_M_current = 0x4}, __last=<br>       {_M_current = 0xfffffffc})<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algo.h:1586<br> #4  0x08048cc3 in std::reverse&lt;__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; (__first={_M_current = 0x4}, __last=<br>       {_M_current = 0x0})<br>     at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algo.h:1611<br> <b><font color="#ff6666">#5  0x080487bc in dummy_function () at iterbug.cpp:17</font></b><br> #6  0x0804891a in main () at iterbug.cpp:40<br> <br> 发现，我们是在<b><font color="#ff6666">0x080487bc in dummy_function () at iterbug.cpp:17</font></b>发生错误，即iterbug.cpp的17行。我们来查看代码。<br> (gdb) l dummy_function()<br> 2       #include &lt;vector&gt;<br> 3       #include &lt;iterator&gt;<br> 4       #include &lt;algorithm&gt;<br> 5       using namespace std;<br> 6<br> 7       void dummy_function(void)<br> 8       {<br> 9               vector&lt;int&gt; coll1;<br> 10              vector&lt;int&gt; coll2;<br> 11<br> (gdb) l<br> 12              /*<br> 13               * RUNTIME ERROR:<br> 14               * - beginning is behind the end of the range<br> 15               */<br> 16              vector&lt;int&gt;::iterator pos = coll1.begin();<br> <b><font color="#ff6666">17              reverse (++pos,coll1.end());</font></b><br> 18<br> 19<br> 20              for ( int i=1; i&lt;=9 ;++i )<br> 21                      coll2.push_back(i);<br> 好了，确实找到了错误所在。<br> 后面就是修正这些逻辑错误了。<br> <br> 上述例子分别来自<a class="moz-txt-link-freetext" href="http://www.upsdn.net/html/2006-11/775.html">http://www.upsdn.net/html/2006-11/775.html</a> 和 The C++ Standard Library A Tutorial and Reference<br> <ol start="2">   <li>不带GDB调试环境</li> </ol> 在很多嵌入式开发环境下，不能提供gdb，因为gdb运行环境太大了。不过一般的嵌入式开发环境会提供objdump等工具，那么可以通过 backtrace来获得堆栈信息，再用objdump来查看获得的堆栈信息与代码的关联。<br> <br> 看<a class="moz-txt-link-freetext" href="http://www.gnu.org/software/libc/manual/html_node/Debugging-Support.html#Debugging">http://www.gnu.org/software/libc/manual/html_node/Debugging-Support.html#Debugging</a> -Support上的说明<br> 摘录如下：<br> <h2 class="chapter">33 Debugging support</h2> <p>Applications are usually debugged using dedicated debugger programs. But sometimes this is not possible and, in any case, it is useful to provide the developer with as much information as possible at the time the problems are experienced. For this reason a few functions are provided which a program can use to help the developer more easily locate the problem. </p> <ul class="menu">   <li><a href="http://www.gnu.org/software/libc/manual/html_node/Backtraces.html#Backtraces">Backtraces</a>: Obtaining and printing a back trace of the current stack. </li> </ul> <br> <h3 class="section">33.1 Backtraces</h3> <p><a name="index-backtrace-3694"></a><a name="index-backtrace_005fsymbols-3695"></a><a name="index-backtrace_005ffd-3696"></a>A backtrace is a list of the function calls that are currently active in a thread. The usual way to inspect a backtrace of a program is to use an external debugger such as gdb. However, sometimes it is useful to obtain a backtrace programmatically from within a program, e.g., for the purposes of logging or diagnostics. </p> <p>The header file <span class="file">execinfo.h</span> declares three functions that obtain and manipulate backtraces of the current thread. <a name="index-execinfo_002eh-3697"></a> <!-- execinfo.h --><!-- GNU --> </p> <div class="defun">— Function: int <b>backtrace</b> (<var>void **buffer, int size</var>)<var><a name="index-backtrace-3698"></a></var><br> <blockquote>   <p>The <code>backtrace</code> function obtains a backtrace for the current thread, as a list of pointers, and places the information into   <var>buffer</var>. The argument <var>size</var> should be the number of   <code>void *</code><!-- /@w --> elements that will fit into <var>buffer</var>. The return value is the actual number of entries of <var>buffer</var> that are obtained, and is at most <var>size</var>. </p>   <p>The pointers placed in <var>buffer</var> are actually return addresses obtained by inspecting the stack, one return address per stack frame. </p>   <p>Note that certain compiler optimizations may interfere with obtaining a valid backtrace. Function inlining causes the inlined function to not have a stack frame; tail call optimization replaces one stack frame with another; frame pointer elimination will stop <code>backtrace</code> from interpreting the stack contents correctly. </p> </blockquote> </div> <!-- execinfo.h --> <!-- GNU --> <div class="defun">— Function: char ** <b>backtrace_symbols</b> (<var>void *const *buffer, int size</var>)<var><a name="index-backtrace_005fsymbols-3699"></a></var><br> <blockquote>   <p>The <code>backtrace_symbols</code> function translates the information obtained from the <code>backtrace</code> function into an array of strings. The argument <var>buffer</var> should be a pointer to an array of addresses obtained via the <code>backtrace</code> function, and <var>size</var> is the number of entries in that array (the return value of <code>backtrace</code>).   </p>   <p>The return value is a pointer to an array of strings, which has   <var>size</var> entries just like the array <var>buffer</var>. Each string contains a printable representation of the corresponding element of   <var>buffer</var>. It includes the function name (if this can be determined), an offset into the function, and the actual return address (in hexadecimal). </p>   <p>Currently, the function name and offset only be obtained on systems that use the ELF binary format for programs and libraries. On other systems, only the hexadecimal return address will be present. Also, you may need to pass additional flags to the linker to make the function names available to the program. (For example, on systems using GNU ld, you must pass (<code>-rdynamic</code>.) </p>   <p>The return value of <code>backtrace_symbols</code> is a pointer obtained via the <code>malloc</code> function, and it is the responsibility of the caller to <code>free</code> that pointer. Note that only the return value need be freed, not the individual strings. </p>   <p>The return value is <code>NULL</code> if sufficient memory for the strings cannot be obtained. </p> </blockquote> </div> <!-- execinfo.h --> <!-- GNU --> <div class="defun">— Function: void <b>backtrace_symbols_fd</b> (<var>void *const *buffer, int size, int fd</var>)<var><a name="index-backtrace_005fsymbols_005ffd-3700"></a></var><br> <blockquote>   <p>The <code>backtrace_symbols_fd</code> function performs the same translation as the function <code>backtrace_symbols</code> function. Instead of returning the strings to the caller, it writes the strings to the file descriptor   <var>fd</var>, one per line. It does not use the <code>malloc</code> function, and can therefore be used in situations where that function might fail. </p> </blockquote> </div> <p>The following program illustrates the use of these functions. Note that the array to contain the return addresses returned by <code>backtrace</code> is allocated on the stack. Therefore code like this can be used in situations where the memory handling via <code>malloc</code> does not work anymore (in which case the <code>backtrace_symbols</code> has to be replaced by a <code>backtrace_symbols_fd</code> call as well). The number of return addresses is normally not very large. Even complicated programs rather seldom have a nesting level of more than, say, 50 and with 200 possible entries probably all programs should be covered. </p> <pre class="smallexample">     #include &lt;execinfo.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;            /* <span class="roman">Obtain a backtrace and print it to </span><code>stdout</code><span class="roman">.</span> */      void      print_trace (void)      {        void *array[10];        size_t size;        char **strings;        size_t i;              size = backtrace (array, 10);        strings = backtrace_symbols (array, size);              printf ("Obtained %zd stack frames.\n", size);              for (i = 0; i &lt; size; i++)           printf ("%s\n", strings[i]);              free (strings);      }            /* <span class="roman">A dummy function to make the backtrace more interesting.</span> */      void      dummy_function (void)      {        print_trace ();      }            int      main (void)      {        dummy_function ();        return 0;      } </pre> 好吧，看了这个说明就大致知道了backtrace等三个函数是如何调用的，以及有什么作用。<br> 更多的可以看<a class="moz-txt-link-freetext" href="http://www.kernel.org/doc/man">http://www.kernel.org/doc/man</a>- pages/online/pages/man3/backtrace.3.html上的man page<br> 这时候再回到<a class="moz-txt-link-freetext" href="http://www.upsdn.net/html/2006-11/775.html上给的一个例子">http://www.upsdn.net/html/2006-11/775.html上给的一个例子</a><br> <br> <span style="font-weight:bold;">.利用backtrace和objdump进行分析:<br> </span>[chen@localhost seg]$ cat -n backtrace.c<br>      1  #include &lt;stdio.h&gt;<br>      2  #include &lt;execinfo.h&gt;<br>      3  #include &lt;stdlib.h&gt;<br>      4  #include &lt;signal.h&gt;<br>      5<br>      6  /*<br>      7   * A dummy function to make the backtrace more interesting.<br>      8   */<br>      9  void<br>     10  dummy_function(void)<br>     11  {<br>     12          unsigned char *ptr = 0x00;<br>    <b><font color="#ff6666"> 13          *ptr = 0x00;</font></b><br>     14  }<br>     15<br>     16  void dump(int signo)<br>     17  {<br>     18          void *array[10];<br>     19          size_t size;<br>     20          char **strings;<br>     21          size_t i;<br>     22<br>     23          size = backtrace(array, 10);<br>     24          strings = backtrace_symbols(array,size);<br>     25<br>     26          printf("Obtained %zd stack frames.\n", size);<br>     27<br>     28<br>     29          for ( i = 0; i &lt; size ; ++i )<br>     30                  printf("%s\n",strings[i]);<br>     31<br>     32          free(strings);<br>     33          exit(0);<br>     34  }<br>     35<br>     36  int<br>     37  main(void)<br>     38  {<br>     39          signal(SIGSEGV, &amp;dump);<br>     40          dummy_function();<br>     41<br>     42          return 0;<br>     43  }<br> 一样是第十三行出现错误<br> <br> gcc -g <font color="#ff6666"><b>-rdynamic</b></font> backtrace.c -o backtrace<br> 编译运行<br> <b>在man page里面说明了使用backtrace函数需要用-rdynamic参数进行编译</b><br> <br> [chen@localhost seg]$ ./backtrace<br> Obtained 5 stack frames.<br> ./backtrace(<font color="#ff6666"><b>dump+0x19</b></font>) [0x80486c2]<br> [0x192420]<br> ./backtrace(<b><font color="#ff6666">main+0x2a</font></b>) [0x8048756]<br> /lib/libc.so.6(__libc_start_main+0xdc) [0x3e1dec]<br> ./backtrace [0x80485e1]<br> 这里打印出了堆栈调用情况<br> 我们用objdump来查看0x8048756这样的地址到底是什么地方<br>  objdump -d -S backtrace &gt; backtrace.dump<br> 查看backtrace.dump文件，搜索上面那几个十六进制地址<br> <br> <br> backtrace:     file format elf32-i386<br> <br> Disassembly of section .init:<br> <br> <br>     ...<br> <br> 08048694 &lt;dummy_function&gt;:<br>  * A dummy function to make the backtrace more interesting.<br>  */<br> void<br> dummy_function(void)<br> {<br>  8048694:    55                       push   %ebp<br>  8048695:    89 e5                    mov    %esp,%ebp<br>  8048697:    83 ec 10                 sub    $0x10,%esp<br>     unsigned char *ptr = 0x00;<br>  804869a:    c7 45 fc 00 00 00 00     movl   $0x0,0xfffffffc(%ebp)<br>     *ptr = 0x00;<br>  80486a1:    8b 45 fc                 mov    0xfffffffc(%ebp),%eax<br>  80486a4:    c6 00 00                 movb   $0x0,(%eax)<br> }<br>  80486a7:    c9                       leave  <br>  80486a8:    c3                       ret    <br> <br> 080486a9 &lt;dump&gt;:<br> <br> void dump(int signo)<br> {<br>  80486a9:    55                       push   %ebp<br>  80486aa:    89 e5                    mov    %esp,%ebp<br>  80486ac:    83 ec 48                 sub    $0x48,%esp<br>     void *array[10];<br>     size_t size;<br>     char **strings;<br>     size_t i;<br> <br>     size = backtrace(array, 10);<br>  80486af:    c7 44 24 04 0a 00 00     movl   $0xa,0x4(%esp)<br>  80486b6:    00 <br>  80486b7:    8d 45 cc                 lea    0xffffffcc(%ebp),%eax<br>  80486ba:    89 04 24                 mov    %eax,(%esp)<br>  80486bd:    e8 c6 fe ff ff           call   8048588 &lt;backtrace@plt&gt;<br>  <font color="#ff6666"><b>80486c2</b></font>:    89 45 f4                 mov    %eax,0xfffffff4(%ebp)<br>     strings = backtrace_symbols(array,size);<br>  80486c5:    8b 45 f4                 mov    0xfffffff4(%ebp),%eax<br>  80486c8:    89 44 24 04              mov    %eax,0x4(%esp)<br>  80486cc:    8d 45 cc                 lea    0xffffffcc(%ebp),%eax<br>  80486cf:    89 04 24                 mov    %eax,(%esp)<br>  80486d2:    e8 91 fe ff ff           call   8048568 &lt;backtrace_symbols@plt&gt;<br>  80486d7:    89 45 f8                 mov    %eax,0xfffffff8(%ebp)<br> <br>     printf("Obtained %zd stack frames.\n", size);<br>  80486da:    8b 45 f4                 mov    0xfffffff4(%ebp),%eax<br>  80486dd:    89 44 24 04              mov    %eax,0x4(%esp)<br>  80486e1:    c7 04 24 40 88 04 08     movl   $0x8048840,(%esp)<br>  80486e8:    e8 8b fe ff ff           call   8048578 &lt;printf@plt&gt;<br> <br> <br>     for ( i = 0; i &lt; size ; ++i )<br>  80486ed:    c7 45 fc 00 00 00 00     movl   $0x0,0xfffffffc(%ebp)<br>  80486f4:    eb 17                    jmp    804870d &lt;dump+0x64&gt;<br>         printf("%s\n",strings[i]);<br>  80486f6:    8b 45 fc                 mov    0xfffffffc(%ebp),%eax<br>  80486f9:    c1 e0 02                 shl    $0x2,%eax<br>  80486fc:    03 45 f8                 add    0xfffffff8(%ebp),%eax<br>  80486ff:    8b 00                    mov    (%eax),%eax<br>  8048701:    89 04 24                 mov    %eax,(%esp)<br>  8048704:    e8 8f fe ff ff           call   8048598 &lt;puts@plt&gt;<br>  8048709:    83 45 fc 01              addl   $0x1,0xfffffffc(%ebp)<br>  804870d:    8b 45 fc                 mov    0xfffffffc(%ebp),%eax<br>  8048710:    3b 45 f4                 cmp    0xfffffff4(%ebp),%eax<br>  8048713:    72 e1                    jb     80486f6 &lt;dump+0x4d&gt;<br> <br>     free(strings);<br>  8048715:    8b 45 f8                 mov    0xfffffff8(%ebp),%eax<br>  8048718:    89 04 24                 mov    %eax,(%esp)<br>  804871b:    e8 38 fe ff ff           call   8048558 &lt;free@plt&gt;<br>     exit(0);<br>  8048720:    c7 04 24 00 00 00 00     movl   $0x0,(%esp)<br>  8048727:    e8 7c fe ff ff           call   80485a8 &lt;exit@plt&gt;<br> <br> 0804872c &lt;main&gt;:<br> }<br> <br> int <br> main(void)<br> {<br>  804872c:    8d 4c 24 04              lea    0x4(%esp),%ecx<br>  8048730:    83 e4 f0                 and    $0xfffffff0,%esp<br>  8048733:    ff 71 fc                 pushl  0xfffffffc(%ecx)<br>  8048736:    55                       push   %ebp<br>  8048737:    89 e5                    mov    %esp,%ebp<br>  8048739:    51                       push   %ecx<br>  804873a:    83 ec 14                 sub    $0x14,%esp<br>     signal(SIGSEGV, &amp;dump);<br>  804873d:    c7 44 24 04 a9 86 04     movl   $0x80486a9,0x4(%esp)<br>  8048744:    08 <br>  8048745:    c7 04 24 0b 00 00 00     movl   $0xb,(%esp)<br>  804874c:    e8 d7 fd ff ff           call   8048528 &lt;signal@plt&gt;<br>     dummy_function();<br>  8048751:    e8 3e ff ff ff           call   8048694 &lt;dummy_function&gt;<br> <br>     return 0;<br>  <font color="#ff6666"><b>8048756</b></font>:    b8 00 00 00 00           mov    $0x0,%eax<br> }<br>  <br>     ...<br> <br> 上面用红色标注出来的就是那几个地址了<br> [chen@localhost seg]$ ./backtrace<br> Obtained 5 stack frames.<br> ./backtrace(<font color="#ff6666"><b>dump+0x19</b></font>) [0x80486c2]<br> [0x192420]<br> ./backtrace(<b><font color="#ff6666">main+0x2a</font></b>) [0x8048756]<br> /lib/libc.so.6(__libc_start_main+0xdc) [0x3e1dec]<br> ./backtrace [0x80485e1]<br> 我们再看看这些地址分析下。<br> 最后一次调用堆栈是 ./backtrace(<font color="#ff6666"><b>dump+0x19</b></font>) [0x80486c2]这肯定是backtrace函数调用，<br> ./backtrace(<b><font color="#ff6666">main+0x2a</font></b>) [0x8048756]则是我们自己写的程序最后出错地方。<br> <font color="#ff6666"><b>8048756</b></font>:    b8 00 00 00 00           mov    $0x0,%eax<br> 对应的是return 0，呵呵，我们出错的地址是在8048756的上一条。即<br> 8048751:    e8 3e ff ff ff           call   8048694 &lt;dummy_function&gt;<br> 所以我们在没有用gdb的情况，可以判断段错误发生在函数dummy_function上，但是具体在哪一行就不能获得。<br> <br> 建议将这些内容看看，如果对这些感兴趣的。<br> <a class="moz-txt-link-freetext" href="http://www.upsdn.net/html/2006-11/775.html">http://www.upsdn.net/html/2006-11/775.html</a><br> <a class="moz-txt-link-freetext" href="http://www.gnu.org/software/libc/manual/html_node/Debugging-Support.html#Debugging-Support">http://www.gnu.org/software/libc/manual/html_node/Debugging-Support.html#Debugging-Support</a><br> <a class="moz-txt-link-freetext" href="http://www.kernel.org/doc/man-pages/online/pages/man3/backtrace.3.html">http://www.kernel.org/doc/man-pages/online/pages/man3/backtrace.3.html</a><br> &lt;完&gt;<br>
